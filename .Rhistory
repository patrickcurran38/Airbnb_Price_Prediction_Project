knitr::opts_chunk$set(echo = TRUE)
packages_to_be_loaded=c("tidyverse", "ggmap", "jsonlite", "rgdal", "GISTools", "sf", "sp", "tmap", "tmaptools",
"maptools", "spatstat", "tigris", "gstat", "deldir", "raster", "leaps", "GWmodel",
"dismo")
lapply(packages_to_be_loaded,function(x){
if(x%in%installed.packages()[,1]==F){ install.packages(x)}
require(x,character.only = T)
})
#Airbnb Property Listings
listings <- read.csv("listings.csv")
knitr::opts_chunk$set(echo = TRUE)
packages_to_be_loaded=c("tidyverse", "ggmap", "jsonlite", "rgdal", "GISTools", "sf", "sp", "tmap", "tmaptools",
"maptools", "spatstat", "tigris", "gstat", "deldir", "raster", "leaps", "GWmodel",
"dismo")
lapply(packages_to_be_loaded,function(x){
if(x%in%installed.packages()[,1]==F){ install.packages(x)}
require(x,character.only = T)
})
#Airbnb Property Listings
listings <- read.csv("listings.csv")
#Neighborhood Shapefile downloaded from http://data.edinburghcouncilmaps.info/datasets/4082b44746eb4da8b5935be2d3a00185_27
neighborhoods <- readOGR("/Users/Patrick/Documents/Rockhurst University/03 Spring 2020/Term A/BIA 6313 - Spatial & GIS Analytics/Week 7/Final Project/neighborhoods")
home_listings <- listings %>%
filter(room_type == "Entire home/apt") %>%
distinct(longitude, latitude, .keep_all = TRUE)
home_listings_clean <- home_listings[ , c("id", "name", "host_id", "host_name", "host_listings_count",
"neighbourhood_cleansed", "country_code", "latitude", "longitude",
"property_type", "room_type", "accommodates", "bathrooms", "bedrooms",
"beds", "price", "extra_people", "minimum_nights", "maximum_nights",
"number_of_reviews", "review_scores_rating", "review_scores_accuracy",
"review_scores_cleanliness", "review_scores_checkin",
"review_scores_communication", "review_scores_location",
"review_scores_value", "reviews_per_month")]
home_listings_clean <- na.omit(home_listings_clean)
home_listings_sf <- st_as_sf(home_listings_clean, coords = c("longitude", "latitude"), crs = 4326)
neighborhoods_sf <- st_as_sf(neighborhoods)
#EPSG:2397 is specific to Scotland
home_listings_sf <- st_transform(home_listings_sf, 2397)
neighborhoods_sf <- st_transform(neighborhoods_sf, 2397)
#Check to make sure they are in the same projection
st_crs(home_listings_sf)
st_crs(neighborhoods_sf)
home_listings_sp <- as(home_listings_sf, "Spatial")
neighborhoods_sp <- as(neighborhoods_sf, "Spatial")
st_is_valid(neighborhoods_sf, reason=TRUE)
neighborhoods_sf <- lwgeom::st_make_valid(neighborhoods_sf)
tmap_mode("view")
tm_shape(neighborhoods_sf) +
tm_borders("black", lwd = 1.5) +
tm_shape(home_listings_sf) +
tm_dots(col="red", size = 0.01, shape = 21, alpha = 0.6) +
tm_layout(title = "Entire Home/Apt Listings")
tmap_mode("plot")
# This code was provide by Dr. Pham from Brunsdon (1st Edition).
home_listings_voro <- voronoi(home_listings_sp)
tmap_mode('view')
tm_shape(home_listings_voro) +
tm_fill(col='price', style='fixed', palette = "YlOrRd", breaks = seq(0, 1000, 200), alpha=0.6,
title="Estimated Price per Night")
tmap_mode("plot")
s.grid <- spsample(neighborhoods_sp, type = 'regular', n = 10000)
idw.est <- gstat::idw(price ~ 1, home_listings_sp, newdata = s.grid, idp = 1.0)
levels <- seq(0, 1000, 200)
tmap_mode('view')
tm_shape(idw.est) + tm_dots(col = 'var1.pred', border.col = NA, alpha = 0.7)
idw.grid <- SpatialPixelsDataFrame(idw.est, data.frame(idw.est))
tm_shape(idw.grid) + tm_raster(col = 'var1.pred', palette = "YlOrRd", alpha = 0.6,
title = "Estimated Price per Night") +
tm_layout(title = "Entire Home/Apt Listings")
tmap_mode("plot")
s.grid2 <- spsample(neighborhoods_sp, type = 'regular', n = 10000)
idw.est2 <- gstat::idw(price ~ 1, home_listings_sp, newdata = s.grid, idp = 2.0)
tmap_mode('view')
tm_shape(idw.est2) + tm_dots(col = 'var1.pred', border.col = NA, alpha = 0.7)
idw.grid2 <- SpatialPixelsDataFrame(idw.est2, data.frame(idw.est2))
tm_shape(idw.grid2) + tm_raster(col = 'var1.pred', palette = "YlOrRd", alpha = 0.6,
title = "Estimated Price per Night") +
tm_layout(title = "Entire Home/Apt Listings")
tmap_mode("plot")
s.grid3 <- spsample(neighborhoods_sp, type = 'regular', n = 10000)
idw.est3 <- gstat::idw(price ~ 1, home_listings_sp, newdata = s.grid, idp = 3.0)
tmap_mode('view')
tm_shape(idw.est3) + tm_dots(col = 'var1.pred', border.col = NA, alpha = 0.7)
idw.grid3 <- SpatialPixelsDataFrame(idw.est2, data.frame(idw.est3))
tm_shape(idw.grid3) + tm_raster(col = 'var1.pred', palette = "YlOrRd", alpha = 0.6,
title = "Estimated Price per Night") +
tm_layout(title = "Entire Home/Apt Listings")
tmap_mode("plot")
home_listings_sp@bbox <- neighborhoods_sp@bbox
tm_shape(neighborhoods_sp) + tm_polygons() +
tm_shape(home_listings_sp) +
tm_dots(col="price", breaks = levels, palette = "Set1", auto.palette.mapping = FALSE,
title="Estimated Price per Night", size=0.1) +
tm_layout(title = "Entire Home/Apt Listings") +
tm_legend(legend.outside=TRUE)
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(home_listings_sp, "regular", n=50000))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add projection information to the empty grid
proj4string(grd) <- proj4string(home_listings_sp)
f.1 <- as.formula(price ~ X + Y)
# Add X and Y to home_listings_sp
home_listings_sp$X <- coordinates(home_listings_sp)[,1]
home_listings_sp$Y <- coordinates(home_listings_sp)[,2]
# Run the regression model
lm.1 <- lm( f.1, data = home_listings_sp)
# Use the regression model output to interpolate the surface
dat.1st <- SpatialGridDataFrame(grd, data.frame(var1.pred = predict(lm.1, newdata = grd)))
# Clip the interpolated raster to Texas
r   <- raster(dat.1st)
r.m <- mask(r, neighborhoods_sp)
# Plot the map
tmap_mode("view")
tm_shape(r.m) +
tm_raster(n = 10, palette = "YlOrRd", alpha = 0.6, title = "Estimated Price per Night") +
tm_shape(home_listings_sp) + tm_dots(size=0.01) +
tm_layout(title = "Entire Home/Apt Listings") +
tm_legend(legend.outside=TRUE)
tmap_mode("plot")
# Define the 2nd order polynomial equation
f.2 <- as.formula(price ~ X + Y + I(X*X) + I(Y*Y) + I(X*Y))
# Add X and Y to home_listing_sp
home_listings_sp$X <- coordinates(home_listings_sp)[,1]
home_listings_sp$Y <- coordinates(home_listings_sp)[,2]
# Run the regression model
lm.2 <- lm( f.2, data = home_listings_sp)
# Use the regression model output to interpolate the surface
dat.2nd <- SpatialGridDataFrame(grd, data.frame(var1.pred = predict(lm.2, newdata = grd)))
# Clip the interpolated raster to Texas
r   <- raster(dat.2nd)
r.m <- mask(r, neighborhoods_sp)
# Plot the map
tmap_mode("view")
tm_shape(r.m) +
tm_raster(n = 10, palette = "YlOrRd", alpha = 0.6, title = "Estimated Price per Night") +
tm_shape(home_listings_sp) + tm_dots(size=0.01) +
tm_layout(title = "Entire Home/Apt Listings") +
tm_legend(legend.outside=TRUE)
tmap_mode("plot")
evgm <- variogram(price ~ 1, home_listings_sp, boundaries = seq(0, 20000, l = 100))
fvgm <- fit.variogram(evgm, fit.ranges = FALSE, fit.sills = FALSE,
vgm(psill = 10000, model = "Exp", range = 6000, nugget = 0))
plot(evgm)
gwr_distance <- gwr.basic(price ~ accommodates + bathrooms + bedrooms,
data = home_listings_sp, bw = 500, kernel = 'gaussian')
gwr_distance
gwr_variable <- gwr.basic(price ~ accommodates + bathrooms + bedrooms,
data = home_listings_sp, adaptive = TRUE, bw = 100)
gwr_variable
